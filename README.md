# 자바 ORM 표준 JPA 프로그래밍

### [인텔리제이에 예제 프로젝트 설정하기(최성훈님 제공)](https://medium.com/@oopchoi/jpa-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-fc443b647ec8)

---
1. ### **JPA 소개**
   1. 애플리케이션에서 SQL을 직접 다룰 때 발생하는 문제점
      1. 진정한 의미의 계층 분할이 어렵다.
      2. 엔티티를 신뢰할 수 없다.
      3. SQL에 의존적인 개발을 피하기 어렵다.
   2. JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다.
2. ### **JPA 시작**
   1. **엔티티 매니저 팩토리**(엔티티 매니저 공장) : 설정 정보를 읽어 JPA를 동작시키기 위한 기반 객체를 만들고 데이터베이스 커넥션 풀도 생성한다. (생성 비용이 큼.)
      1. 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용해야 한다.
   2. **엔티티 매니저** : 엔티티를 데이터베이스에 CRUD 할 수 있다. 
      1. 데이터베이스 커넥션과 밀접한 관계가 있으므로 **스레드 간에 공유하거나 재사용하면 안 된다.**
      2. persist(), remove(), find() 
3. ### **영속성 관리**
   1. 엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다. 예를 들어 트랜잭션이 시작할 때 커넥션을 획득한다.
   2. 영속성 컨텍스트(엔티티를 영구 저장하는 환경)
      1. 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
   3. **엔티티 생명주기**
      1. 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
      2. 영속(managed) : 영속성 컨텍스트에 저장된 상태
      3. 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
         1. 특징
            1. 거의 비영속 상태에 가깝다.
            2. 식별자 값을 가지고 있다.
            3. 지연 로딩을 할 수 없다.
      4. 삭제(removed) : 삭제된 상태
   4. 영속성 컨텍스트의 특징
      1. 영속 상태는 식별자 값이 반드시 있어야 한다.
      2. 데이터베이스에 저장되는 시점은 트랜잭션을 커밋 하는 순간(flush)이다.
   5. **영속성 컨텍스트의 장점**
      1. **1차 캐시** : em.find()를 호출하면 먼저 1차 캐시에서 엔티티를 찾고 만약 찾는 엔티티가 1차 캐시에 없으면 데이터베이스를 조회한다.
      2. **동일성 보장** : 1차 캐시에 있는 같은 엔티티 인스턴스를 반환하기 때문에 동일성이 보장된다.
      3. **트랜잭션을 지원하는 쓰기 지연** : 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보낸다.
      4. **변경 감지** : 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능 (**영속 상태의 엔티티에만 적용**)
      5. **지연 로딩**
   6. **플러시**
      1. 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.
      2. 영속성 컨텍스트에 보관된 엔티티를 지우는 것이 아닌 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화 하는 행위! 
      3. 플러시 방법
         1. em.flush()를 직접 호출한다.
         2. 트랜잭션 커밋 시 플러시가 자동 호출된다.
         3. JPQL 쿼리 실행 시 플러시가 자동 호출된다.
4. ### **엔티티 매핑**
   1. 기본키 매핑
      1. 직접 할당 : 기본 키를 애플리케이션에서 직접 할당한다.
      2. 자동 생성 : 대리 키 사용 방식
         1. **IDENTITY** : 기본 키 생성을 데이터베이스에 위임한다.
            1. **엔티티가 영속 상태가 되려면 식별자가 반드시 필요하다. 따라서 이 전략은 em.persist()를 호출하는 즉시 INSERT SQL이 데이터베이스에 전달되며 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.**
         2. SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다.
            1. em.persist()를 호출할 때 먼저 데이터베이스 시퀀스를 사용해서 식별자를 조회한다. 그리고 조회한 식별자를 엔티티에 할당한 후에 엔티티를 영속성 컨텍스트에 저장한다.
         3. TABLE : 키 생성 테이블을 사용한다.
5. ### **연관관계 매핑 기초**
   1. 연관관계의 주인 (외래키가 있는 곳)
      1. 엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나다. 따라서 둘 사이에 차이가 발생한다. 이런 차이로 인해 JPA는 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 하는데 이것을 연관관계의 주인이라 한다.
      2. 양방향 매핑의 규칙
         1. 주인은 mappedBy 속성을 사용하지 않는다.
         2. 주인이 아니면 mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야 한다.
         3. 예시
            1. `team.getMembers().add(member); // 무시 (연관관계의 주인이 아님)`
            2. `member.setTeam(team); // 연관관계 설정 (연관관계의 주인)`
      3. 순수한 객체까지 고려한 양방향 연관관계 : 객체까지 고려해서 주인이 아닌 곳에도 값을 입력하자!
         1. 연관관계 편의 메서드 주의사항 : 기존 관계 제거!!
6. ### **다양한 연관관계 매핑**
   1. 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자!
   2. 일대일 [1:1]
      1. 주 테이블에 외래 키
         1. 주 테이블만 확인해도 대상 테이블과 연관관계가 있는지 알 수 있다.
      2. 대상 테이블에 외래 키
         1. 테이블 관계를 일대일에서 일대다로 변경할 때 테이블 구조를 유지할 수 있다.
      3. 프록시를 사용할 때 외래 키를 직접 관리하지 않는 일대일 관계는 지연 로딩으로 설정해도 즉시 로딩된다.
   3. 다대다
      1. 다대다 관계는 연결 테이블을 JPA가 알아서 처리해주므로 편리하지만 연결 테이블에 필드가 추가되면 더는 사용할 수 없으므로 실무에서 활용하기에는 무리가 있다. 따라서 연결 엔티티를 만들어서 일대다, 다대일 관계로 매핑하는 것을 권장한다.
7. ### **고급 매핑**
   1. 상속 관계 매핑
      1. 조인 전략 : 각각의 테이블로 변환
         1. @Inheritance(strategy = InheritanceType.JOINED), @PrimaryKeyJoinColumn, @DiscriminatorColumn, @DiscriminatorValue
      2. 단일 테이블 전략 : 통합 테이블로 변환
         1. @Inheritance(strategy = InheritanceType.SINGLE_TABLE), @DiscriminatorColumn, @DiscriminatorValue
      3. 구현 클래스마다 테이블 전략 : 서브타입 테이블로 변환
         1. @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
   2. @MappedSuperClass
      1. 테이블과 매핑되지 않고 자식 클래스에 엔티티의 매핑 정보를 상속하기 위해 사용한다.
      2. @MappedSuperClass로 지정한 클래스는 엔티티가 아니므로 em.find()나 JPQL에서 사용할 수 없다.
      3. 이 클래스르 직접 생성해서 사용할 일은 거의 없으므로 추상 클래스로 만드는 것을 권장한다.
   3. 복합 키와 식별 관계 매핑
      1. 식별 관계 vs 비식별 관계 : 외래 키가 기본 키에 포함되는지 여부에 따라 구분
         1. 필수적 비식별 관계 vs 선택적 비식별 관계 : 외래 키 NULL 허용 여부
      2. 복합 키
         1. @IdClass, @EmbeddedId
         2. 복합 키는 equals(), hashCode()를 필수로 구현해야 한다.
      3. 일대일 식별 관계 - @MapsId
      4. 식별 관계 vs 비식별 관계
         1. 식별 : 기본 키 인덱스를 활용하기 좋고, 상위 테이블들의 기본 키 컬럼을 자식, 손자 테이블들이 가지고 있으므로 특정 상황에 조인 없이 하위 테이블만으로 검색을 완료할 수 있다.
         2. 비식별 : ORM 신규 프로젝트 진행시 추천하는 방법은 비식별 관계를 사용하고 기본 키는 Long 타입의 대리 키를 사용하는 것이다.
   4. 조인 테이블
      1. 조인 컬럼 사용 (FK) : @JoinColumn
      2. 조인 테이블 사용 (테이블) : @JoinTable
         
